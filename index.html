<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEON PACMAN - JUICED EDITION</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000011;display:flex;justify-content:center;align-items:center;min-height:100vh;font-family:'Orbitron',monospace;overflow:hidden}
#container{position:relative;border:2px solid #0ff;border-radius:8px;box-shadow:0 0 30px #0ff,0 0 60px #0ff3,inset 0 0 30px #0001;padding:10px;background:#000008}
canvas{display:block}
#muteBtn{position:absolute;top:12px;right:12px;background:none;border:1px solid #0ff4;color:#0ff;font-family:'Orbitron',monospace;font-size:11px;padding:4px 8px;cursor:pointer;border-radius:4px;z-index:10;text-shadow:0 0 5px #0ff}
#muteBtn:hover{background:#0ff2}
@keyframes containerGlow{
  0%{box-shadow:0 0 30px #0ff,0 0 60px #0ff3,inset 0 0 30px #0001}
  16%{box-shadow:0 0 30px #f0f,0 0 60px #f0f3,inset 0 0 30px #0001}
  33%{box-shadow:0 0 30px #ff0,0 0 60px #ff03,inset 0 0 30px #0001}
  50%{box-shadow:0 0 30px #0f0,0 0 60px #0f03,inset 0 0 30px #0001}
  66%{box-shadow:0 0 30px #f80,0 0 60px #f803,inset 0 0 30px #0001}
  83%{box-shadow:0 0 30px #08f,0 0 60px #08f3,inset 0 0 30px #0001}
  100%{box-shadow:0 0 30px #0ff,0 0 60px #0ff3,inset 0 0 30px #0001}
}
#container{animation:containerGlow 4s infinite ease-in-out;border-color:#0ff}
@keyframes borderColor{0%{border-color:#0ff}25%{border-color:#f0f}50%{border-color:#ff0}75%{border-color:#0f0}100%{border-color:#0ff}}
#container{animation:containerGlow 4s infinite ease-in-out,borderColor 6s infinite linear}
</style>
</head>
<body>
<div id="container">
<button id="muteBtn">ðŸ”Š</button>
<canvas id="game"></canvas>
</div>
<script>
'use strict';
const COLS=28,ROWS=31,T=24,W=COLS*T,H=ROWS*T,HUD_H=40;
const canvas=document.getElementById('game');
canvas.width=W;canvas.height=H+HUD_H;
const ctx=canvas.getContext('2d');

// Maze: 0=empty,1=wall,2=dot,3=power,5=door
const MAZE_TEMPLATE=[
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
[1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
[1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
[1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
[1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
[1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
[0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
[0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
[0,0,0,0,0,1,2,1,1,0,1,1,1,5,5,1,1,1,0,1,1,2,1,0,0,0,0,0],
[1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
[0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
[1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
[0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
[0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
[0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
[1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
[1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
[1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
[1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
[1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
[1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
[1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
[1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Audio
const audioCtx=new(window.AudioContext||window.webkitAudioContext)();
let muted=false,musicEl=null;
function initMusic(){
  if(musicEl)return;
  musicEl=new Audio('assets/music.mp3');
  musicEl.loop=true;musicEl.volume=0.3;
  musicEl.play().catch(()=>{});
}
function playTone(freq,dur,type='square',vol=0.08){
  if(muted)return;
  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
  o.type=type;o.frequency.value=freq;
  g.gain.setValueAtTime(vol,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
  o.connect(g);g.connect(audioCtx.destination);
  o.start();o.stop(audioCtx.currentTime+dur);
}
function sfxDot(){playTone(600+Math.random()*200,0.06,'square',0.04)}
function sfxPower(){
  [400,500,600,800,1000].forEach((f,i)=>setTimeout(()=>playTone(f,0.1,'sine',0.07),i*40));
}
function sfxGhostEat(){playTone(1200,0.15,'sine',0.1);setTimeout(()=>playTone(1600,0.2,'sine',0.08),60)}
function sfxDeath(){
  [800,600,400,300,200,150].forEach((f,i)=>setTimeout(()=>playTone(f,0.15,'sawtooth',0.06),i*80));
}
document.getElementById('muteBtn').addEventListener('click',()=>{
  muted=!muted;
  document.getElementById('muteBtn').textContent=muted?'ðŸ”‡':'ðŸ”Š';
  if(musicEl)musicEl.muted=muted;
});

// Game state
let maze,score,highScore=0,lives,level,dotsLeft,gameState,readyTimer;
let pacman,ghosts,particles,floatingTexts;
let shakeX=0,shakeY=0,shakeDur=0,flashAlpha=0;
let modeTimer,modeIndex,scatterChase; // 'scatter' or 'chase'
const MODE_SCHEDULE=[[7,20],[7,20],[5,20],[5,999999]]; // scatter/chase seconds
let frightenedTimer=0,ghostEatCombo;
let globalFrame=0;

// Juice state
let juiceState={
  // Pacman trail ribbon (#2)
  pacTrail:[],
  // Ghost afterimages (#3)
  ghostTrails:{},
  // Speed lines (#4)
  speedLines:[],
  // Pulse waves (#5)
  pulseWaves:[],
  // Combo system (#7)
  dotStreak:0,comboTimer:0,lastPacDir:null,comboTexts:[],
  // Score pop (#8)
  scorePop:0,scorePopText:'',scorePopX:0,scorePopY:0,lastScore:0,
  // Stars (#13)
  stars:[],
  // Dot ripples (#12)
  dotRipples:[],dotsEatenCount:0,
  // Death effect (#10)
  deathSlowMo:0,deathDesaturate:0,deathShockwave:null,
  // Ghost eat celebration (#11)
  ghostFreeze:0,ghostZoom:null,lightningBolts:[],
  // Level complete (#9)
  levelFlashTimer:0,levelFlashColors:['#0ff','#f0f','#ff0','#0f0','#f80','#08f'],levelTextScale:0,levelParticles:false,
  // Power mode
  powerAtmosphere:0,
  // Screen zoom
  screenZoom:1,
  // Fruit
  fruit:null,
  // Kill streak
  ghostsEatenThisPower:0,
  // Near miss
  nearMissTimer:0
};

// Directions
const DIR={NONE:{x:0,y:0},UP:{x:0,y:-1},DOWN:{x:0,y:1},LEFT:{x:-1,y:0},RIGHT:{x:1,y:0}};
const DIRS=[DIR.UP,DIR.DOWN,DIR.LEFT,DIR.RIGHT];

function tileCenter(gx,gy){return{x:gx*T+T/2,y:gy*T+T/2+HUD_H}}
function pxToGrid(px,py){return{x:Math.floor(px/T),y:Math.floor((py-HUD_H)/T)}}
function atTileCenter(px,py){
  const cx=Math.floor(px/T)*T+T/2;
  const cy=Math.floor((py-HUD_H)/T)*T+T/2+HUD_H;
  return Math.abs(px-cx)<1.5&&Math.abs(py-cy)<1.5;
}
function snapToCenter(ent){
  ent.x=Math.floor(ent.x/T)*T+T/2;
  ent.y=Math.floor((ent.y-HUD_H)/T)*T+T/2+HUD_H;
}
function isPassable(gx,gy,isGhost){
  // Tunnel wrap
  if(gy===14&&(gx<0||gx>=COLS))return true;
  if(gx<0||gx>=COLS||gy<0||gy>=ROWS)return false;
  const t=maze[gy][gx];
  if(t===1)return false;
  if(t===5)return !!isGhost;
  return true;
}
function dist(ax,ay,bx,by){return Math.abs(ax-bx)+Math.abs(ay-by)}
function eucDist(ax,ay,bx,by){return Math.sqrt((ax-bx)**2+(ay-by)**2)}

// Particles
function spawnParticle(x,y,color,count=5,speed=2,life=30){
  for(let i=0;i<count;i++){
    if(particles.length>100)break; // cap particles for performance
    const a=Math.random()*Math.PI*2;
    const s=Math.random()*speed+0.5;
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life,maxLife:life,color,size:Math.random()*3+1});
  }
}
function spawnTrail(x,y){
  particles.push({x:x+Math.random()*4-2,y:y+Math.random()*4-2,vx:0,vy:0,life:15,maxLife:15,color:'#ff0',size:2});
}

// Floating text
function spawnFloat(x,y,text,color='#fff'){
  floatingTexts.push({x,y,text,color,life:60,maxLife:60});
}

function triggerShake(dur=8){shakeDur=dur}
function triggerFlash(){flashAlpha=0.3}

// Initialize game
function initGame(){
  score=0;lives=3;level=1;gameState='title';
  particles=[];floatingTexts=[];
  juiceState.stars=[];
  for(let i=0;i<60;i++){
    juiceState.stars.push({x:Math.random()*W,y:Math.random()*H+HUD_H,alpha:Math.random(),phase:Math.random()*Math.PI*2,speed:0.1+Math.random()*0.3,size:Math.random()*1.5+0.5});
  }
  juiceState.lastScore=0;
  juiceState.dotStreak=0;juiceState.comboTimer=0;juiceState.comboTexts=[];
  juiceState.dotsEatenCount=0;
}

function resetLevel(){
  maze=MAZE_TEMPLATE.map(r=>[...r]);
  dotsLeft=0;
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(maze[y][x]===2||maze[y][x]===3)dotsLeft++;
  frightenedTimer=0;ghostEatCombo=0;
  modeIndex=0;modeTimer=MODE_SCHEDULE[0][0]*60;scatterChase='scatter';
  resetPositions();
  gameState='ready';readyTimer=120;
  juiceState.pacTrail=[];
  juiceState.ghostTrails={};
  juiceState.speedLines=[];
  juiceState.pulseWaves=[];
  juiceState.dotRipples=[];
  juiceState.dotStreak=0;juiceState.comboTimer=0;juiceState.comboTexts=[];
  juiceState.deathSlowMo=0;juiceState.deathDesaturate=0;juiceState.deathShockwave=null;
  juiceState.ghostFreeze=0;juiceState.ghostZoom=null;juiceState.lightningBolts=[];
  juiceState.levelFlashTimer=0;juiceState.levelTextScale=0;juiceState.levelParticles=false;
  juiceState.powerAtmosphere=0;
  juiceState.scorePop=0;
  juiceState.screenZoom=1;
  juiceState.fruit=null;
  juiceState.ghostsEatenThisPower=0;
  juiceState.nearMissTimer=0;
}

function resetPositions(){
  const pc=tileCenter(14,23);
  pacman={x:pc.x,y:pc.y,dir:DIR.LEFT,nextDir:DIR.NONE,mouthAngle:0,mouthDir:1,speed:2,deathTimer:0,deathFrame:0};

  const ghostDefs=[
    {name:'blinky',color:'#ff0000',gx:14,gy:11,inHouse:false,scatterX:25,scatterY:0,releaseTime:0},
    {name:'pinky',color:'#ffb8ff',gx:13,gy:14,inHouse:true,scatterX:2,scatterY:0,releaseTime:180},
    {name:'inky',color:'#00ffff',gx:14,gy:14,inHouse:true,scatterX:27,scatterY:30,releaseTime:420},
    {name:'clyde',color:'#ffb852',gx:15,gy:14,inHouse:true,scatterX:0,scatterY:30,releaseTime:720}
  ];
  ghosts=ghostDefs.map(d=>{
    const p=tileCenter(d.gx,d.gy);
    return{
      name:d.name,color:d.color,x:p.x,y:p.y,
      dir:d.inHouse?DIR.UP:DIR.LEFT,
      speed:1.6+level*0.08,
      inHouse:d.inHouse,exiting:false,
      scatterX:d.scatterX,scatterY:d.scatterY,
      releaseTime:d.releaseTime,releaseCounter:0,
      frightened:false,eaten:false,
      bouncePhase:Math.random()*Math.PI*2
    };
  });
}

// Pacman movement
function movePacman(){
  if(pacman.deathTimer>0)return;
  const spd=pacman.speed;
  
  if(atTileCenter(pacman.x,pacman.y)){
    snapToCenter(pacman);
    const g=pxToGrid(pacman.x,pacman.y);
    
    // Tunnel wrap
    if(g.y===14){
      if(g.x<0){pacman.x=tileCenter(COLS-1,14).x;return;}
      if(g.x>=COLS){pacman.x=tileCenter(0,14).x;return;}
    }
    
    // Try next direction
    const nx=g.x+pacman.nextDir.x,ny=g.y+pacman.nextDir.y;
    if(pacman.nextDir!==DIR.NONE&&isPassable(nx,ny,false)){
      pacman.dir=pacman.nextDir;
    }else{
      const cx=g.x+pacman.dir.x,cy=g.y+pacman.dir.y;
      if(!isPassable(cx,cy,false)){
        pacman.dir=DIR.NONE;
        return;
      }
    }
    if(pacman.dir===DIR.NONE)return;
  }
  
  if(pacman.dir===DIR.NONE)return;
  pacman.x+=pacman.dir.x*spd;
  pacman.y+=pacman.dir.y*spd;
  
  // Tunnel wrap pixel level
  if(pacman.y===tileCenter(0,14).y){
    if(pacman.x<-T)pacman.x=W+T/2;
    if(pacman.x>W+T)pacman.x=-T/2;
  }
  
  // Trail
  if(globalFrame%3===0)spawnTrail(pacman.x,pacman.y);
}

// Ghost AI
function getGhostTarget(g){
  const pg=pxToGrid(pacman.x,pacman.y);
  if(g.frightened)return{x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
  if(g.eaten){
    // Return to house entrance
    return{x:13,y:11};
  }
  if(scatterChase==='scatter'&&!g.frightened){
    return{x:g.scatterX,y:g.scatterY};
  }
  // Chase targets
  switch(g.name){
    case'blinky':return{x:pg.x,y:pg.y};
    case'pinky':{
      let tx=pg.x+pacman.dir.x*4,ty=pg.y+pacman.dir.y*4;
      // Original bug: when facing up, target is 4 up and 4 left
      if(pacman.dir===DIR.UP){tx-=4;}
      return{x:tx,y:ty};
    }
    case'inky':{
      const blinky=ghosts[0];
      const bg=pxToGrid(blinky.x,blinky.y);
      let ax=pg.x+pacman.dir.x*2,ay=pg.y+pacman.dir.y*2;
      if(pacman.dir===DIR.UP){ax-=2;}
      return{x:ax*2-bg.x,y:ay*2-bg.y};
    }
    case'clyde':{
      const d=eucDist(pxToGrid(g.x,g.y).x,pxToGrid(g.x,g.y).y,pg.x,pg.y);
      if(d<8)return{x:g.scatterX,y:g.scatterY};
      return{x:pg.x,y:pg.y};
    }
  }
  return{x:pg.x,y:pg.y};
}

function moveGhost(g){
  if(g.inHouse){
    g.releaseCounter++;
    // Bounce in house
    g.bouncePhase+=0.08;
    const baseY=tileCenter(0,14).y;
    g.y=baseY+Math.sin(g.bouncePhase)*6;
    if(g.releaseCounter>=g.releaseTime){
      g.exiting=true;g.inHouse=false;
    }
    return;
  }
  
  if(g.exiting){
    // Move to door then out
    const doorX=tileCenter(13,11).x+T/2;
    const doorY=tileCenter(13,11).y;
    const exitSpeed=1.5;
    
    // First align X to column 13.5 (between 13 and 14)
    if(Math.abs(g.x-doorX)>2){
      g.x+=(doorX>g.x?1:-1)*exitSpeed;
      return;
    }
    g.x=doorX;
    // Then move up to row 11
    if(Math.abs(g.y-doorY)>2){
      g.y+=(doorY>g.y?1:-1)*exitSpeed;
      return;
    }
    g.y=doorY;
    g.exiting=false;
    g.dir=DIR.LEFT;
    snapToCenter(g);
    return;
  }
  
  const spd=g.eaten?4:(g.frightened?1.2:g.speed);
  
  if(atTileCenter(g.x,g.y)){
    snapToCenter(g);
    const gg=pxToGrid(g.x,g.y);
    
    // Tunnel wrap
    if(gg.y===14){
      if(gg.x<=0&&g.dir===DIR.LEFT){g.x=tileCenter(COLS-1,14).x;return;}
      if(gg.x>=COLS-1&&g.dir===DIR.RIGHT){g.x=tileCenter(0,14).x;return;}
    }
    
    // Check if eaten ghost reached house
    if(g.eaten&&gg.x>=12&&gg.x<=15&&gg.y===11){
      g.eaten=false;g.frightened=false;
      g.x=tileCenter(13,14).x+T/2;g.y=tileCenter(13,14).y;
      g.exiting=true;
      return;
    }
    
    const target=getGhostTarget(g);
    const reverse={x:-g.dir.x,y:-g.dir.y};
    
    // Get valid directions
    let validDirs=DIRS.filter(d=>{
      if(d.x===reverse.x&&d.y===reverse.y)return false;
      return isPassable(gg.x+d.x,gg.y+d.y,true);
    });
    
    if(validDirs.length===0){
      // Dead end, allow reverse
      validDirs=DIRS.filter(d=>isPassable(gg.x+d.x,gg.y+d.y,true));
    }
    
    if(validDirs.length===0){g.dir=DIR.NONE;return;}
    
    if(g.frightened&&!g.eaten){
      // Random direction when frightened
      g.dir=validDirs[Math.floor(Math.random()*validDirs.length)];
    }else{
      // Pick direction closest to target
      let bestDir=validDirs[0],bestDist=Infinity;
      for(const d of validDirs){
        const dx=gg.x+d.x,dy=gg.y+d.y;
        const dd=eucDist(dx,dy,target.x,target.y);
        if(dd<bestDist){bestDist=dd;bestDir=d;}
      }
      g.dir=bestDir;
    }
  }
  
  if(g.dir===DIR.NONE)return;
  g.x+=g.dir.x*spd;
  g.y+=g.dir.y*spd;
  
  // Tunnel wrap pixel
  if(pxToGrid(g.x,g.y).y===14||Math.abs(g.y-tileCenter(0,14).y)<T){
    if(g.x<-T)g.x=W+T/2;
    if(g.x>W+T)g.x=-T/2;
  }
}

// Collisions
function checkCollisions(){
  if(pacman.deathTimer>0)return;
  const pg=pxToGrid(pacman.x,pacman.y);
  if(pg.x<0||pg.x>=COLS||pg.y<0||pg.y>=ROWS)return;
  
  // Dot
  if(maze[pg.y][pg.x]===2){
    maze[pg.y][pg.x]=0;score+=10;dotsLeft--;
    sfxDot();triggerShake(3);
    spawnParticle(pacman.x,pacman.y,'#ff0',3,1,15);
    // Juice: combo system
    juiceState.dotStreak++;juiceState.comboTimer=60;
    juiceState.dotsEatenCount++;
    const ds=juiceState.dotStreak;
    if(ds===5){juiceState.comboTexts.push({x:pacman.x,y:pacman.y,text:'5x COMBO!',life:90,maxLife:90});triggerShake(4);}
    else if(ds===10){juiceState.comboTexts.push({x:pacman.x,y:pacman.y,text:'10x STREAK!',life:90,maxLife:90});triggerShake(6);}
    else if(ds===20){juiceState.comboTexts.push({x:pacman.x,y:pacman.y,text:'20x INSANE!',life:120,maxLife:120});triggerShake(8);}
    else if(ds===50){juiceState.comboTexts.push({x:pacman.x,y:pacman.y,text:'50x GODLIKE!',life:150,maxLife:150});triggerShake(12);}
    // Juice: score pop
    juiceState.scorePop=20;juiceState.scorePopText='+10';
    // Juice: dot ripple every 5th dot
    if(juiceState.dotsEatenCount%5===0){
      juiceState.dotRipples.push({x:pacman.x,y:pacman.y,radius:0,maxRadius:40,life:30,maxLife:30});
    }
    // Juice: fruit spawn every 70 dots
    if(juiceState.dotsEatenCount%70===0&&!juiceState.fruit){
      const fruitTypes=[{type:'C',color:'#ff2222',points:100},{type:'S',color:'#ff4488',points:300},{type:'O',color:'#ff8800',points:500},{type:'A',color:'#44ff44',points:700},{type:'M',color:'#44ff88',points:1000}];
      const fi=Math.min(Math.floor(juiceState.dotsEatenCount/70)-1,fruitTypes.length-1);
      const ft=fruitTypes[fi];
      const fp=tileCenter(14,17);
      juiceState.fruit={x:fp.x,y:fp.y,type:ft.type,color:ft.color,points:ft.points,timer:300};
    }
  }
  // Power pellet
  if(maze[pg.y][pg.x]===3){
    maze[pg.y][pg.x]=0;score+=50;dotsLeft--;
    sfxPower();
    frightenedTimer=360;ghostEatCombo=0;
    juiceState.ghostsEatenThisPower=0;
    ghosts.forEach(g=>{
      if(!g.inHouse&&!g.exiting&&!g.eaten){
        g.frightened=true;
        g.dir={x:-g.dir.x,y:-g.dir.y};
      }
    });
    triggerShake(8);
    juiceState.screenZoom=1.03;
    spawnParticle(pacman.x,pacman.y,'#f0f',8,2,25);
    // Juice: wall pulse wave (smaller, faster)
    juiceState.pulseWaves.push({x:pacman.x,y:pacman.y,radius:0,maxRadius:150,life:30});
    // Juice: score pop
    juiceState.scorePop=25;juiceState.scorePopText='+50';
  }
  
  // Fruit collision
  if(juiceState.fruit){
    const fd=eucDist(pacman.x,pacman.y,juiceState.fruit.x,juiceState.fruit.y);
    if(fd<T*0.8){
      const fr=juiceState.fruit;
      score+=fr.points;
      spawnParticle(fr.x,fr.y,fr.color,25,4,50);
      spawnFloat(fr.x,fr.y,'+'+fr.points,fr.color);
      triggerShake(8);
      juiceState.scorePop=25;juiceState.scorePopText='+'+fr.points;
      juiceState.fruit=null;
    }
  }
  
  // Level complete
  if(dotsLeft<=0){
    level++;
    flashAlpha=0.5;
    // Juice: level complete animation
    juiceState.levelFlashTimer=90;juiceState.levelTextScale=0.01;juiceState.levelParticles=true;
    spawnParticle(W/2,H/2+HUD_H,'#0ff',20,4,40);
    spawnParticle(W/2,H/2+HUD_H,'#f0f',20,4,40);
    spawnParticle(W/2,H/2+HUD_H,'#ff0',20,4,40);
    setTimeout(()=>resetLevel(),2500);
    gameState='levelcomplete';
    return;
  }
  
  // Ghost collisions
  for(const g of ghosts){
    if(g.inHouse||g.exiting||g.eaten)continue;
    const d=eucDist(pacman.x,pacman.y,g.x,g.y);
    if(d<T*0.7){
      if(g.frightened){
        // Eat ghost
        g.eaten=true;g.frightened=false;
        ghostEatCombo++;
        juiceState.ghostsEatenThisPower++;
        const pts=[200,400,800,1600][Math.min(ghostEatCombo-1,3)];
        score+=pts;
        sfxGhostEat();
        triggerShake(12);triggerFlash();
        spawnFloat(g.x,g.y,pts.toString(),'#0ff');
        spawnParticle(g.x,g.y,g.color,20,3,40);
        // Juice: ghost eat celebration
        juiceState.ghostFreeze=12;
        juiceState.ghostZoom={x:g.x,y:g.y,timer:20};
        juiceState.scorePop=30;juiceState.scorePopText='+'+pts;
        // Lightning bolts from ghost to edges
        for(let li=0;li<6;li++){
          const angle=Math.random()*Math.PI*2;
          juiceState.lightningBolts.push({x:g.x,y:g.y,angle,life:15,maxLife:15});
        }
        // Rainbow massive score float
        juiceState.comboTexts.push({x:g.x,y:g.y-10,text:pts+'!!',life:90,maxLife:90,rainbow:true,massive:true});
      }else{
        // Pacman dies
        pacmanDie();
      }
    }else if(d<T*2.5&&!g.frightened&&juiceState.nearMissTimer<=0){
      // Near miss!
      juiceState.nearMissTimer=60;
      triggerShake(4);
    }
  }
}

function pacmanDie(){
  pacman.deathTimer=90;pacman.deathFrame=0;
  sfxDeath();triggerShake(15);
  lives--;
  spawnParticle(pacman.x,pacman.y,'#ff0',50,5,60);
  spawnParticle(pacman.x,pacman.y,'#f80',30,4,50);
  spawnParticle(pacman.x,pacman.y,'#f00',20,3,40);
  // Juice: death effects
  juiceState.deathSlowMo=30;
  juiceState.deathDesaturate=1;
  juiceState.deathShockwave={x:pacman.x,y:pacman.y,radius:0,maxRadius:200,life:40,maxLife:40};
}

// Update
function update(){
  globalFrame++;
  
  if(shakeDur>0){
    shakeDur--;
    shakeX=(Math.random()-0.5)*shakeDur*0.5;
    shakeY=(Math.random()-0.5)*shakeDur*0.5;
  }else{shakeX=0;shakeY=0;}
  if(flashAlpha>0)flashAlpha-=0.02;
  
  // Particles
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vx*=0.95;p.vy*=0.95;p.life--;
    return p.life>0;
  });
  floatingTexts=floatingTexts.filter(f=>{f.y-=1.2;f.life--;return f.life>0;});
  
  // Juice updates
  // Stars
  for(const s of juiceState.stars){
    s.phase+=0.02;s.alpha=0.3+Math.sin(s.phase)*0.4;
    s.y+=s.speed*(frightenedTimer>0?3:1);
    if(s.y>H+HUD_H){s.y=HUD_H;s.x=Math.random()*W;}
  }
  // Combo timer
  if(juiceState.comboTimer>0){juiceState.comboTimer--;}
  else{juiceState.dotStreak=0;}
  // Combo texts
  juiceState.comboTexts=juiceState.comboTexts.filter(c=>{c.y-=1.5;c.life--;return c.life>0;});
  // Score pop
  if(juiceState.scorePop>0)juiceState.scorePop--;
  // Dot ripples
  juiceState.dotRipples=juiceState.dotRipples.filter(r=>{r.radius+=2;r.life--;return r.life>0;});
  // Fruit timer
  if(juiceState.fruit){juiceState.fruit.timer--;if(juiceState.fruit.timer<=0)juiceState.fruit=null;}
  // Pulse waves
  juiceState.pulseWaves=juiceState.pulseWaves.filter(pw=>{pw.radius+=5;pw.life--;return pw.life>0;});
  // Death effects
  if(juiceState.deathDesaturate>0)juiceState.deathDesaturate-=0.015;
  if(juiceState.deathShockwave){
    juiceState.deathShockwave.radius+=5;juiceState.deathShockwave.life--;
    if(juiceState.deathShockwave.life<=0)juiceState.deathShockwave=null;
  }
  // Ghost freeze
  if(juiceState.ghostFreeze>0)juiceState.ghostFreeze--;
  // Ghost zoom
  if(juiceState.ghostZoom){juiceState.ghostZoom.timer--;if(juiceState.ghostZoom.timer<=0)juiceState.ghostZoom=null;}
  // Lightning bolts
  juiceState.lightningBolts=juiceState.lightningBolts.filter(l=>{l.life--;return l.life>0;});
  // Level flash
  if(juiceState.levelFlashTimer>0){juiceState.levelFlashTimer--;juiceState.levelTextScale=Math.min(juiceState.levelTextScale+0.05,1);}
  // Power atmosphere lerp
  juiceState.powerAtmosphere+=(frightenedTimer>0?1:0-juiceState.powerAtmosphere)*0.05;
  // Screen zoom lerp
  if(juiceState.screenZoom>1.001)juiceState.screenZoom+=(1-juiceState.screenZoom)*0.08;
  // Near miss timer
  if(juiceState.nearMissTimer>0)juiceState.nearMissTimer--;
  // Pacman trail
  if(pacman&&pacman.deathTimer<=0&&pacman.dir!==DIR.NONE){
    juiceState.pacTrail.unshift({x:pacman.x,y:pacman.y});
    if(juiceState.pacTrail.length>18)juiceState.pacTrail.length=18;
  }
  // Ghost trails
  if(ghosts)for(const g of ghosts){
    if(!juiceState.ghostTrails[g.name])juiceState.ghostTrails[g.name]=[];
    juiceState.ghostTrails[g.name].unshift({x:g.x,y:g.y,frightened:g.frightened,eaten:g.eaten,color:g.color});
    if(juiceState.ghostTrails[g.name].length>8)juiceState.ghostTrails[g.name].length=8;
  }
  // Speed lines
  if(pacman&&pacman.dir!==DIR.NONE&&pacman.deathTimer<=0){
    for(let i=0;i<2;i++){
      const ox=(Math.random()-0.5)*T*2;const oy=(Math.random()-0.5)*T*2;
      juiceState.speedLines.push({x:pacman.x+ox,y:pacman.y+oy,dx:-pacman.dir.x,dy:-pacman.dir.y,life:10,maxLife:10,len:8+Math.random()*12});
    }
  }
  juiceState.speedLines=juiceState.speedLines.filter(sl=>{sl.x+=sl.dx*3;sl.y+=sl.dy*3;sl.life--;return sl.life>0;});
  
  if(gameState==='ready'){
    readyTimer--;
    if(readyTimer<=0)gameState='playing';
    return;
  }
  if(gameState!=='playing')return;
  
  // Death animation
  if(pacman.deathTimer>0){
    pacman.deathTimer--;
    pacman.deathFrame++;
    if(pacman.deathTimer<=0){
      if(lives<=0){
        gameState='gameover';
        if(score>highScore)highScore=score;
      }else{
        resetPositions();
        gameState='ready';readyTimer=90;
      }
    }
    return;
  }
  
  // Mode timer
  if(frightenedTimer>0){
    frightenedTimer--;
    if(frightenedTimer<=0){
      ghosts.forEach(g=>{g.frightened=false;});
    }
  }else{
    modeTimer--;
    if(modeTimer<=0){
      const isScatter=scatterChase==='scatter';
      if(isScatter){
        scatterChase='chase';
        modeTimer=MODE_SCHEDULE[Math.min(modeIndex,3)][1]*60;
      }else{
        modeIndex++;
        if(modeIndex>=MODE_SCHEDULE.length){
          scatterChase='chase';modeTimer=999999;
        }else{
          scatterChase='scatter';
          modeTimer=MODE_SCHEDULE[modeIndex][0]*60;
        }
      }
      // Reverse ghost directions on mode switch
      ghosts.forEach(g=>{
        if(!g.inHouse&&!g.exiting&&!g.eaten&&!g.frightened){
          g.dir={x:-g.dir.x,y:-g.dir.y};
        }
      });
    }
  }
  
  // Mouth animation (always runs, even when stopped)
  pacman.mouthAngle+=0.15*pacman.mouthDir;
  if(pacman.mouthAngle>0.8)pacman.mouthDir=-1;
  if(pacman.mouthAngle<0.05)pacman.mouthDir=1;
  
  movePacman();
  if(juiceState.ghostFreeze<=0)ghosts.forEach(moveGhost);
  checkCollisions();
}

// ======================== DRAWING ========================

function drawBackground(){
  ctx.fillStyle='#000011';
  ctx.fillRect(0,0,W,H+HUD_H);
  
  // Scrolling grid
  const gridOff=(globalFrame*0.3)%T;
  ctx.strokeStyle='#0a0a2a';ctx.lineWidth=0.5;
  for(let x=gridOff;x<W;x+=T){ctx.beginPath();ctx.moveTo(x,HUD_H);ctx.lineTo(x,H+HUD_H);ctx.stroke();}
  for(let y=gridOff+HUD_H;y<H+HUD_H;y+=T){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}
}

// Wall rendering - draw inner edges
function drawMaze(){
  const hue=(globalFrame*0.5)%360;
  
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(maze[y][x]!==1&&maze[y][x]!==5)continue;
      
      const px=x*T,py=y*T+HUD_H;
      const isDoor=maze[y][x]===5;
      
      if(isDoor){
        ctx.save();
        ctx.strokeStyle='#f0f';
        ctx.shadowColor='#f0f';ctx.shadowBlur=8;
        ctx.lineWidth=3;
        ctx.beginPath();
        ctx.moveTo(px,py+T/2);ctx.lineTo(px+T,py+T/2);
        ctx.stroke();
        ctx.restore();
        continue;
      }
      
      // Draw edges facing non-wall tiles
      const pa=juiceState.powerAtmosphere;
      let baseHue;
      if(pa>0.1){baseHue=280+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*20;}
      else if(level===1){baseHue=200+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*20;}
      else if(level===2){baseHue=120+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*20;}
      else if(level===3){baseHue=290+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*20;}
      else if(level===4){baseHue=15+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*15;}
      else if(level===5){baseHue=50+Math.sin(globalFrame*0.02+x*0.1+y*0.1)*10;}
      else{baseHue=(globalFrame*0.5+x*2+y*2)%360;}
      const wallHue=baseHue;
      const wallColor=`hsl(${wallHue},100%,${60+pa*10}%)`;
      const glowHues={1:'#00aaff',2:'#00ff44',3:'#cc44ff',4:'#ff6600',5:'#ffcc00'};
      const glowColor=pa>0.1?'#cc44ff':(glowHues[level]||`hsl(${wallHue},100%,60%)`);
      ctx.save();
      ctx.strokeStyle=wallColor;
      ctx.shadowColor=glowColor;ctx.shadowBlur=8+pa*4;
      ctx.lineWidth=2;
      
      // Check each neighbor
      const neighbors=[
        {dx:0,dy:-1,x1:px,y1:py,x2:px+T,y2:py},       // top
        {dx:0,dy:1,x1:px,y1:py+T,x2:px+T,y2:py+T},     // bottom
        {dx:-1,dy:0,x1:px,y1:py,x2:px,y2:py+T},         // left
        {dx:1,dy:0,x1:px+T,y1:py,x2:px+T,y2:py+T}       // right
      ];
      
      for(const n of neighbors){
        const nx=x+n.dx,ny=y+n.dy;
        let neighborIsWall=false;
        if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS){
          neighborIsWall=maze[ny][nx]===1;
        }else{
          // Out of bounds - treat as wall for edge tiles, non-wall for tunnel
          neighborIsWall=(ny!==14);
        }
        if(!neighborIsWall){
          ctx.beginPath();
          ctx.moveTo(n.x1,n.y1);ctx.lineTo(n.x2,n.y2);
          ctx.stroke();
        }
      }
      ctx.restore();
    }
  }
}

function drawDots(){
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const px=x*T+T/2,py=y*T+T/2+HUD_H;
      if(maze[y][x]===2){
        ctx.save();
        ctx.fillStyle='#ffdd44';
        ctx.shadowColor='#ffdd44';ctx.shadowBlur=6;
        ctx.beginPath();ctx.arc(px,py,2.5,0,Math.PI*2);ctx.fill();
        ctx.restore();
      }else if(maze[y][x]===3){
        const pulse=0.7+Math.sin(globalFrame*0.08)*0.3;
        const hue=(globalFrame*3+x*50+y*50)%360;
        ctx.save();
        // Outer glow ring
        ctx.strokeStyle=`hsl(${hue},100%,70%)`;
        ctx.shadowColor=`hsl(${hue},100%,80%)`;
        ctx.shadowBlur=15*pulse;
        ctx.lineWidth=2;
        ctx.beginPath();ctx.arc(px,py,8*pulse,0,Math.PI*2);ctx.stroke();
        // Inner fill
        ctx.fillStyle=`hsl(${hue},100%,70%)`;
        ctx.shadowBlur=18*pulse;
        ctx.beginPath();ctx.arc(px,py,6*pulse,0,Math.PI*2);ctx.fill();
        // Center bright spot
        ctx.fillStyle='#ffffff';
        ctx.shadowBlur=10;
        ctx.beginPath();ctx.arc(px,py,2*pulse,0,Math.PI*2);ctx.fill();
        ctx.restore();
      }
    }
  }
}

function drawPacman(){
  if(pacman.deathTimer>0){
    // Death animation
    const prog=pacman.deathFrame/90;
    const angle=prog*Math.PI;
    ctx.save();
    ctx.translate(pacman.x+shakeX,pacman.y+shakeY);
    ctx.shadowColor='#ff0';ctx.shadowBlur=15;
    ctx.fillStyle='#ffe000';
    ctx.beginPath();
    ctx.arc(0,0,T*0.45,angle,-angle);
    ctx.lineTo(0,0);ctx.closePath();ctx.fill();
    ctx.restore();
    return;
  }
  
  // Track last movement direction for mouth facing
  if(pacman.dir!==DIR.NONE)pacman.lastDir=pacman.dir;
  const faceDir=pacman.lastDir||DIR.RIGHT;
  
  let angle=0;
  if(faceDir===DIR.RIGHT)angle=0;
  else if(faceDir===DIR.DOWN)angle=Math.PI/2;
  else if(faceDir===DIR.LEFT)angle=Math.PI;
  else if(faceDir===DIR.UP)angle=-Math.PI/2;
  
  const mouth=pacman.mouthAngle*0.8;
  const pa=juiceState.powerAtmosphere;
  const r=T*0.45*(1+pa*0.15);
  const px=pacman.x+shakeX,py=pacman.y+shakeY;
  
  // Chromatic aberration
  const layers=[
    {color:'rgba(255,60,60,0.3)',ox:-1,oy:0},
    {color:'rgba(60,255,60,0.3)',ox:1,oy:0},
    {color:'#ffe000',ox:0,oy:0}
  ];
  
  ctx.save();
  ctx.shadowColor='#ff0';ctx.shadowBlur=15+pa*5;
  for(const l of layers){
    ctx.fillStyle=l.color;
    ctx.beginPath();
    ctx.arc(px+l.ox,py+l.oy,r,angle+mouth,angle+Math.PI*2-mouth);
    ctx.lineTo(px+l.ox,py+l.oy);
    ctx.closePath();ctx.fill();
  }
  ctx.restore();
  // Eye
  const eyeAngle=angle;
  const eyeX=px+Math.cos(eyeAngle)*r*0.15+Math.cos(eyeAngle+Math.PI/2)*r*0.3;
  const eyeY=py+Math.sin(eyeAngle)*r*0.15+Math.sin(eyeAngle+Math.PI/2)*r*0.3;
  ctx.fillStyle='#fff';ctx.shadowBlur=0;
  ctx.beginPath();ctx.arc(eyeX,eyeY,3,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#000';
  ctx.beginPath();ctx.arc(eyeX+Math.cos(eyeAngle)*1.2,eyeY+Math.sin(eyeAngle)*1.2,1.5,0,Math.PI*2);ctx.fill();
}

function drawGhost(g){
  if(g.eaten){
    // Just eyes
    drawGhostEyes(g.x+shakeX,g.y+shakeY,g.dir,1);
    return;
  }
  
  const isFrightened=g.frightened;
  const px=g.x+shakeX+(isFrightened?(Math.random()-0.5)*4:0),py=g.y+shakeY+(isFrightened?(Math.random()-0.5)*4:0);
  const r=T*0.45;
  const flashWhite=isFrightened&&frightenedTimer<120&&Math.floor(globalFrame/8)%2===0;
  
  ctx.save();
  
  let bodyColor=g.color;
  if(isFrightened)bodyColor=flashWhite?'#ffffff':'#2222cc';
  
  ctx.fillStyle=bodyColor;
  ctx.shadowColor=bodyColor;ctx.shadowBlur=15;
  
  // Body
  ctx.beginPath();
  ctx.arc(px,py-2,r,Math.PI,0);
  
  // Wavy bottom
  const segments=6;
  const segW=r*2/segments;
  const waveAmp=3;
  const bottomY=py+r-2;
  for(let i=0;i<=segments;i++){
    const sx=px-r+i*segW;
    const soff=Math.sin(globalFrame*0.15+i*1.2)*waveAmp;
    if(i===0)ctx.lineTo(sx,bottomY);
    else ctx.quadraticCurveTo(sx-segW/2,bottomY+(i%2===0?waveAmp:-waveAmp)+soff,sx,bottomY);
  }
  ctx.closePath();ctx.fill();
  
  // Eyes
  if(isFrightened){
    // Frightened face
    const eyeY=py-3;
    ctx.fillStyle=flashWhite?'#000':'#fff';
    ctx.beginPath();ctx.arc(px-4,eyeY,2.5,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(px+4,eyeY,2.5,0,Math.PI*2);ctx.fill();
    
    // Wavy mouth
    ctx.strokeStyle=flashWhite?'#000':'#fff';
    ctx.lineWidth=1.5;
    ctx.beginPath();
    const mouthY=py+3;
    for(let i=0;i<7;i++){
      const mx=px-6+i*2;
      const my=mouthY+(i%2===0?-1:1)*1.5;
      if(i===0)ctx.moveTo(mx,my);else ctx.lineTo(mx,my);
    }
    ctx.stroke();
  }else{
    drawGhostEyes(px,py,g.dir,1);
  }
  
  ctx.restore();
}

function drawGhostEyes(px,py,dir,scale){
  const eyeY=py-3;
  const eyeR=4*scale;
  const pupilR=2*scale;
  let pupilOx=0,pupilOy=0;
  if(dir===DIR.LEFT){pupilOx=-2;}
  else if(dir===DIR.RIGHT){pupilOx=2;}
  else if(dir===DIR.UP){pupilOy=-2;}
  else if(dir===DIR.DOWN){pupilOy=2;}
  
  // White of eyes
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.ellipse(px-5,eyeY,eyeR,eyeR+1,0,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(px+5,eyeY,eyeR,eyeR+1,0,0,Math.PI*2);ctx.fill();
  
  // Pupils
  ctx.fillStyle='#00f';
  ctx.beginPath();ctx.arc(px-5+pupilOx,eyeY+pupilOy,pupilR,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(px+5+pupilOx,eyeY+pupilOy,pupilR,0,Math.PI*2);ctx.fill();
}

function drawParticles(){
  ctx.save();
  for(const p of particles){
    const alpha=p.life/p.maxLife;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=p.color;
    ctx.shadowColor=p.color;ctx.shadowBlur=4;
    ctx.beginPath();ctx.arc(p.x+shakeX,p.y+shakeY,p.size*alpha,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawFloatingTexts(){
  for(const f of floatingTexts){
    const alpha=f.life/f.maxLife;
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.fillStyle=f.color;
    ctx.shadowColor=f.color;ctx.shadowBlur=10;
    ctx.font='bold 14px Orbitron';
    ctx.textAlign='center';
    ctx.fillText(f.text,f.x+shakeX,f.y+shakeY);
    ctx.restore();
  }
}

function drawHUD(){
  ctx.save();
  // Score with pop effect
  const sp=juiceState.scorePop;
  const scoreScale=1+sp*0.02;
  ctx.fillStyle='#fff';ctx.shadowColor='#0ff';ctx.shadowBlur=8+sp;
  ctx.font=`bold ${Math.floor(16*scoreScale)}px Orbitron`;ctx.textAlign='left';
  ctx.fillText('SCORE: '+score,10,28);
  
  // High score
  ctx.textAlign='center';
  ctx.fillStyle='#ff0';ctx.shadowColor='#ff0';
  ctx.fillText('HI: '+highScore,W/2,28);
  
  // Level
  ctx.textAlign='right';
  ctx.fillStyle='#0f0';ctx.shadowColor='#0f0';
  ctx.fillText('LVL '+level,W-80,28);
  
  // Lives
  ctx.fillStyle='#ffe000';ctx.shadowColor='#ff0';ctx.shadowBlur=6;
  for(let i=0;i<lives;i++){
    const lx=W-20-i*28,ly=22;
    ctx.beginPath();
    ctx.arc(lx,ly,8,0.3,Math.PI*2-0.3);
    ctx.lineTo(lx,ly);ctx.closePath();ctx.fill();
  }
  ctx.restore();
}

function drawCRT(){
  // Scanlines
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.06)';
  for(let y=0;y<H+HUD_H;y+=3){
    ctx.fillRect(0,y,W,1);
  }
  
  // Vignette
  const vg=ctx.createRadialGradient(W/2,(H+HUD_H)/2,W*0.3,W/2,(H+HUD_H)/2,W*0.8);
  vg.addColorStop(0,'transparent');
  vg.addColorStop(1,'rgba(0,0,0,0.5)');
  ctx.fillStyle=vg;
  ctx.fillRect(0,0,W,H+HUD_H);
  ctx.restore();
}

function drawFlash(){
  if(flashAlpha>0){
    ctx.save();
    ctx.fillStyle=`rgba(255,255,255,${flashAlpha})`;
    ctx.fillRect(0,0,W,H+HUD_H);
    ctx.restore();
  }
}

function drawTitleScreen(){
  drawBackground();
  drawStarField();
  
  // Pulsing neon border
  ctx.save();
  const borderHue=(globalFrame*2)%360;
  ctx.strokeStyle=`hsl(${borderHue},100%,60%)`;
  ctx.shadowColor=`hsl(${borderHue},100%,60%)`;ctx.shadowBlur=20;
  ctx.lineWidth=2;
  ctx.strokeRect(10,HUD_H+10,W-20,H-20);
  ctx.restore();
  
  // Rainbow title with multiple glow layers
  const title='NEON PACMAN';
  ctx.save();
  // Background glow layer
  ctx.font='bold 44px Orbitron';ctx.textAlign='center';
  const bgHue=(globalFrame*2)%360;
  ctx.fillStyle=`hsl(${bgHue},100%,50%)`;
  ctx.shadowColor=`hsl(${bgHue},100%,50%)`;ctx.shadowBlur=20;
  ctx.globalAlpha=0.3;
  ctx.fillText(title,W/2+2,H/2-58+HUD_H/2);
  ctx.globalAlpha=1;
  // Main title
  ctx.font='bold 42px Orbitron';
  for(let i=0;i<title.length;i++){
    const hue=(globalFrame*3+i*30)%360;
    ctx.fillStyle=`hsl(${hue},100%,60%)`;
    ctx.shadowColor=`hsl(${hue},100%,60%)`;ctx.shadowBlur=20;
    const charW=ctx.measureText(title.substring(0,i)).width;
    const totalW=ctx.measureText(title).width;
    ctx.fillText(title[i],W/2-totalW/2+charW+12,H/2-60+HUD_H/2);
  }
  
  // JUICED EDITION subtitle
  ctx.font='bold 18px Orbitron';
  const juicedAlpha=0.7+Math.sin(globalFrame*0.08)*0.3;
  ctx.globalAlpha=juicedAlpha;
  ctx.fillStyle='#ff1493';
  ctx.shadowColor='#ff1493';ctx.shadowBlur=25;
  ctx.fillText('JUICED EDITION',W/2,H/2-25+HUD_H/2);
  ctx.globalAlpha=1;
  
  // Pulsing start text
  const alpha=0.5+Math.sin(globalFrame*0.05)*0.5;
  ctx.globalAlpha=alpha;
  ctx.font='18px Orbitron';
  ctx.fillStyle='#fff';ctx.shadowColor='#fff';ctx.shadowBlur=10;
  ctx.fillText('PRESS SPACE OR CLICK TO START',W/2,H/2+20+HUD_H/2);
  ctx.globalAlpha=1;
  
  // Decorative pacman
  const dpx=W/2+Math.cos(globalFrame*0.03)*80;
  const dpy=H/2+80+HUD_H/2;
  ctx.fillStyle='#ffe000';ctx.shadowColor='#ff0';ctx.shadowBlur=15;
  const dm=0.3+Math.abs(Math.sin(globalFrame*0.1))*0.5;
  ctx.beginPath();ctx.arc(dpx,dpy,16,dm,-dm);ctx.lineTo(dpx,dpy);ctx.closePath();ctx.fill();
  
  // Dots trail
  for(let i=0;i<6;i++){
    const ddx=dpx-20-i*16;
    ctx.fillStyle='#ffdd44';ctx.shadowBlur=6;
    ctx.beginPath();ctx.arc(ddx,dpy,3,0,Math.PI*2);ctx.fill();
  }
  
  // Floating ghost sprites
  const ghostColors=['#ff0000','#ffb8ff','#00ffff','#ffb852'];
  for(let gi=0;gi<4;gi++){
    const gx=W*0.15+gi*(W*0.22);
    const gy=H/2+140+HUD_H/2+Math.sin(globalFrame*0.04+gi*1.5)*15;
    const gr=10;
    ctx.fillStyle=ghostColors[gi];
    ctx.shadowColor=ghostColors[gi];ctx.shadowBlur=12;
    ctx.beginPath();ctx.arc(gx,gy-2,gr,Math.PI,0);
    ctx.lineTo(gx+gr,gy+gr-2);
    for(let s=0;s<3;s++){
      const sx=gx+gr-s*(gr*2/3);
      ctx.quadraticCurveTo(sx-gr/3,gy+gr+(s%2===0?-3:3),sx-gr*2/3,gy+gr-2);
    }
    ctx.closePath();ctx.fill();
    // Eyes
    ctx.fillStyle='#fff';
    ctx.beginPath();ctx.arc(gx-3,gy-3,3,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(gx+3,gy-3,3,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#00f';
    ctx.beginPath();ctx.arc(gx-3,gy-3,1.5,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(gx+3,gy-3,1.5,0,Math.PI*2);ctx.fill();
  }
  
  ctx.restore();
  drawCRT();
}

function drawGameOverScreen(){
  drawBackground();
  drawStarField();
  drawMaze();drawDots();
  
  ctx.save();
  // Darken
  ctx.fillStyle='rgba(0,0,0,0.6)';
  ctx.fillRect(0,HUD_H,W,H);
  
  ctx.font='bold 36px Orbitron';ctx.textAlign='center';
  ctx.fillStyle='#f00';ctx.shadowColor='#f00';ctx.shadowBlur=20;
  ctx.fillText('GAME OVER',W/2,H/2-20+HUD_H/2);
  
  ctx.font='20px Orbitron';
  ctx.fillStyle='#fff';ctx.shadowColor='#fff';ctx.shadowBlur=10;
  ctx.fillText('SCORE: '+score,W/2,H/2+20+HUD_H/2);
  
  const alpha=0.5+Math.sin(globalFrame*0.05)*0.5;
  ctx.globalAlpha=alpha;
  ctx.font='16px Orbitron';
  ctx.fillText('PRESS SPACE TO RESTART',W/2,H/2+60+HUD_H/2);
  ctx.globalAlpha=1;
  ctx.restore();
  
  drawHUD();
  drawCRT();
}

function drawReadyScreen(){
  drawBackground();
  drawBassPulse();
  drawStarField();
  drawMaze();drawDots();
  ghosts.forEach(drawGhost);
  drawPacman();
  
  ctx.save();
  ctx.font='bold 28px Orbitron';ctx.textAlign='center';
  ctx.fillStyle='#ff0';ctx.shadowColor='#ff0';ctx.shadowBlur=20;
  ctx.fillText('READY!',W/2,H/2+HUD_H/2);
  ctx.restore();
  
  drawHUD();
  drawCRT();
}

// ======================== JUICE DRAWING ========================

function drawBassPulse(){
  const isPower=frightenedTimer>0;
  const pulseRate=isPower?0.12:0.05;
  const pulseIntensity=Math.sin(globalFrame*pulseRate);
  if(pulseIntensity>0.7){
    const alpha=isPower?(pulseIntensity-0.7)*0.06:(pulseIntensity-0.7)*0.05;
    ctx.save();
    ctx.fillStyle=isPower?`rgba(60,0,50,${alpha})`:`rgba(30,30,80,${alpha})`;
    ctx.fillRect(0,0,W,H+HUD_H);
    ctx.restore();
  }
}

function drawStarField(){
  // Effect #13
  const isPower=frightenedTimer>0;
  ctx.save();
  for(const s of juiceState.stars){
    const alpha=Math.max(0,s.alpha);
    ctx.globalAlpha=alpha*0.6;
    if(isPower){
      const hue=(globalFrame*5+s.x+s.y)%360;
      ctx.fillStyle=`hsl(${hue},100%,70%)`;
    }else{
      ctx.fillStyle='#ffffff';
    }
    ctx.beginPath();ctx.arc(s.x,s.y,s.size,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawPacTrail(){
  // Effect #2: Neon trail ribbon
  if(juiceState.pacTrail.length<2)return;
  const isPower=frightenedTimer>0;
  ctx.save();
  for(let i=1;i<juiceState.pacTrail.length;i++){
    const p0=juiceState.pacTrail[i-1],p1=juiceState.pacTrail[i];
    const frac=1-i/juiceState.pacTrail.length;
    const alpha=frac*0.7;
    const width=(juiceState.pacTrail.length-i)*0.6;
    ctx.globalAlpha=alpha;
    if(isPower){
      const hue=(globalFrame*8+i*40)%360;
      ctx.strokeStyle=`hsl(${hue},100%,60%)`;
      ctx.shadowColor=`hsl(${hue},100%,60%)`;
    }else{
      const r=255,g_=Math.max(0,255-i*20),b=Math.max(0,80-i*15);
      ctx.strokeStyle=`rgb(${r},${g_},${b})`;
      ctx.shadowColor='#ff8800';
    }
    ctx.shadowBlur=8*frac;
    ctx.lineWidth=width;
    ctx.beginPath();ctx.moveTo(p0.x+shakeX,p0.y+shakeY);ctx.lineTo(p1.x+shakeX,p1.y+shakeY);ctx.stroke();
  }
  ctx.restore();
}

function drawGhostTrails(){
  // Effect #3: Ghost afterimage trail
  ctx.save();
  for(const g of ghosts){
    const trail=juiceState.ghostTrails[g.name];
    if(!trail)continue;
    for(let i=1;i<trail.length;i++){
      const t=trail[i];
      const alpha=(trail.length-i)/trail.length*0.3;
      ctx.globalAlpha=alpha;
      if(t.eaten){
        // White eye afterimages
        drawGhostEyes(t.x+shakeX,t.y+shakeY,g.dir,0.7);
      }else{
        const px=t.x+shakeX,py=t.y+shakeY;
        const r=T*0.35;
        ctx.fillStyle=t.frightened?'#2222cc':t.color;
        ctx.beginPath();ctx.arc(px,py-2,r,Math.PI,0);ctx.lineTo(px+r,py+r-4);ctx.lineTo(px-r,py+r-4);ctx.closePath();ctx.fill();
      }
    }
  }
  ctx.restore();
}

function drawSpeedLines(){
  // Effect #4
  if(juiceState.speedLines.length===0)return;
  ctx.save();
  for(const sl of juiceState.speedLines){
    const alpha=sl.life/sl.maxLife*0.3;
    ctx.globalAlpha=alpha;
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(sl.x+shakeX,sl.y+shakeY);
    ctx.lineTo(sl.x+sl.dx*sl.len+shakeX,sl.y+sl.dy*sl.len+shakeY);
    ctx.stroke();
  }
  ctx.restore();
}

function drawPulseWaves(){
  for(const pw of juiceState.pulseWaves){
    const alpha=pw.life/30*0.4;
    ctx.save();
    ctx.strokeStyle=`rgba(255,0,255,${alpha})`;
    ctx.shadowColor='#f0f';ctx.shadowBlur=6;
    ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(pw.x+shakeX,pw.y+shakeY,pw.radius,0,Math.PI*2);ctx.stroke();
    ctx.restore();
  }
}

function drawDotRipples(){
  // Effect #12: Dot ripples
  ctx.save();
  for(const r of juiceState.dotRipples){
    const alpha=r.life/r.maxLife*0.5;
    ctx.globalAlpha=alpha;
    ctx.strokeStyle='#ffdd44';
    ctx.shadowColor='#ffdd44';ctx.shadowBlur=8;
    ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(r.x+shakeX,r.y+shakeY,r.radius,0,Math.PI*2);ctx.stroke();
  }
  ctx.restore();
}

function drawDotMagnetize(){
  // Effect #12: Dots near Pacman visually shift toward Pacman (purely visual)
  if(pacman.deathTimer>0)return;
  const pg=pxToGrid(pacman.x,pacman.y);
  for(let dy=-3;dy<=3;dy++){
    for(let dx=-3;dx<=3;dx++){
      const gx=pg.x+dx,gy=pg.y+dy;
      if(gx<0||gx>=COLS||gy<0||gy>=ROWS)continue;
      if(maze[gy][gx]!==2)continue;
      const dotX=gx*T+T/2,dotY=gy*T+T/2+HUD_H;
      const d=eucDist(pacman.x,pacman.y,dotX,dotY);
      if(d<T*3&&d>T*0.5){
        const pull=Math.max(0,(T*3-d)/(T*3))*3;
        const ang=Math.atan2(pacman.y-dotY,pacman.x-dotX);
        const vx=Math.cos(ang)*pull,vy=Math.sin(ang)*pull;
        ctx.save();
        ctx.fillStyle='#ffdd44';
        ctx.shadowColor='#ffdd44';ctx.shadowBlur=6;
        ctx.globalAlpha=0.6;
        ctx.beginPath();ctx.arc(dotX+vx+shakeX,dotY+vy+shakeY,2.5,0,Math.PI*2);ctx.fill();
        ctx.restore();
      }
    }
  }
}

function drawComboTexts(){
  // Effect #7
  ctx.save();
  for(const c of juiceState.comboTexts){
    const frac=c.life/c.maxLife;
    const alpha=Math.min(1,frac*2);
    const scale=c.massive?2+Math.sin(c.life*0.2)*0.3:1.5;
    const fontSize=c.massive?Math.floor(32*scale):Math.floor(24*scale);
    ctx.globalAlpha=alpha;
    const hue=(globalFrame*10+c.life*5)%360;
    ctx.fillStyle=`hsl(${hue},100%,60%)`;
    ctx.shadowColor=`hsl(${hue},100%,60%)`;ctx.shadowBlur=15;
    ctx.font=`bold ${fontSize}px Orbitron`;
    ctx.textAlign='center';
    ctx.fillText(c.text,c.x+shakeX,c.y+shakeY);
  }
  ctx.restore();
}

function drawLightningBolts(){
  // Effect #11
  if(juiceState.lightningBolts.length===0)return;
  ctx.save();
  for(const l of juiceState.lightningBolts){
    const alpha=l.life/l.maxLife;
    ctx.globalAlpha=alpha;
    ctx.strokeStyle='#ffffff';
    ctx.shadowColor='#0ff';ctx.shadowBlur=15;
    ctx.lineWidth=2;
    ctx.beginPath();
    let cx=l.x+shakeX,cy=l.y+shakeY;
    ctx.moveTo(cx,cy);
    const len=Math.max(W,H);
    const segments=8;
    for(let s=0;s<segments;s++){
      cx+=Math.cos(l.angle)*len/segments+(Math.random()-0.5)*20;
      cy+=Math.sin(l.angle)*len/segments+(Math.random()-0.5)*20;
      ctx.lineTo(cx,cy);
    }
    ctx.stroke();
  }
  ctx.restore();
}

function drawDeathShockwave(){
  // Effect #10
  if(!juiceState.deathShockwave)return;
  const sw=juiceState.deathShockwave;
  const alpha=sw.life/sw.maxLife;
  ctx.save();
  ctx.strokeStyle=`rgba(255,255,0,${alpha})`;
  ctx.shadowColor='#ff0';ctx.shadowBlur=20;
  ctx.lineWidth=3;
  ctx.beginPath();ctx.arc(sw.x+shakeX,sw.y+shakeY,sw.radius,0,Math.PI*2);ctx.stroke();
  ctx.restore();
}

function drawDeathDesaturate(){
  // Effect #10: desaturation overlay
  if(juiceState.deathDesaturate>0.01){
    ctx.save();
    ctx.globalAlpha=juiceState.deathDesaturate*0.4;
    ctx.fillStyle='#444';
    ctx.globalCompositeOperation='saturation';
    ctx.fillRect(0,0,W,H+HUD_H);
    ctx.restore();
  }
}

function drawGhostZoom(){
  // Effect #11: zoom circle on ghost eat location
  if(!juiceState.ghostZoom)return;
  const gz=juiceState.ghostZoom;
  const frac=gz.timer/20;
  const radius=T*(2-frac);
  ctx.save();
  ctx.strokeStyle=`rgba(0,255,255,${frac})`;
  ctx.shadowColor='#0ff';ctx.shadowBlur=20;
  ctx.lineWidth=3;
  ctx.beginPath();ctx.arc(gz.x+shakeX,gz.y+shakeY,radius,0,Math.PI*2);ctx.stroke();
  ctx.restore();
}

function drawPowerAtmosphere(){
  const a=juiceState.powerAtmosphere;
  if(a<0.01)return;
  ctx.save();
  ctx.globalAlpha=a*0.06;
  ctx.fillStyle='#200018';
  ctx.fillRect(0,0,W,H+HUD_H);
  ctx.restore();
}

function drawPowerChromaticAberration(){
  const a=juiceState.powerAtmosphere;
  if(a<0.3)return;
  ctx.save();
  ctx.globalAlpha=a*0.08;
  // Red tint on left edge
  const grad1=ctx.createLinearGradient(0,0,60,0);
  grad1.addColorStop(0,'rgba(255,0,0,0.3)');
  grad1.addColorStop(1,'transparent');
  ctx.fillStyle=grad1;
  ctx.fillRect(0,0,60,H+HUD_H);
  // Blue tint on right edge
  const grad2=ctx.createLinearGradient(W-60,0,W,0);
  grad2.addColorStop(0,'transparent');
  grad2.addColorStop(1,'rgba(0,80,255,0.3)');
  ctx.fillStyle=grad2;
  ctx.fillRect(W-60,0,60,H+HUD_H);
  ctx.restore();
}

function drawLevelComplete(){
  // Effect #9
  if(juiceState.levelFlashTimer<=0)return;
  const flash=juiceState.levelFlashTimer;
  // Flash maze walls with neon colors
  if(flash>30){
    const colorIdx=Math.floor(globalFrame/3)%juiceState.levelFlashColors.length;
    ctx.save();
    ctx.globalAlpha=0.3;
    ctx.fillStyle=juiceState.levelFlashColors[colorIdx];
    ctx.fillRect(0,HUD_H,W,H);
    ctx.restore();
  }
  // Big LEVEL COMPLETE text
  const scale=juiceState.levelTextScale;
  const hue=(globalFrame*8)%360;
  ctx.save();
  ctx.globalAlpha=Math.min(1,flash/30);
  ctx.font=`bold ${Math.floor(36*scale)}px Orbitron`;
  ctx.textAlign='center';
  ctx.fillStyle=`hsl(${hue},100%,60%)`;
  ctx.shadowColor=`hsl(${hue},100%,80%)`;ctx.shadowBlur=20;
  ctx.fillText('LEVEL COMPLETE!',W/2,H/2+HUD_H/2);
  ctx.restore();
}

function drawScorePop(){
  // Effect #8
  if(juiceState.scorePop<=0)return;
  // Mini text flying up from score
  const frac=juiceState.scorePop/30;
  ctx.save();
  ctx.globalAlpha=frac;
  ctx.fillStyle='#0ff';
  ctx.shadowColor='#0ff';ctx.shadowBlur=10;
  ctx.font=`bold ${12+juiceState.scorePop*0.5}px Orbitron`;
  ctx.textAlign='left';
  ctx.fillText(juiceState.scorePopText,120,28-((30-juiceState.scorePop)*1.5));
  ctx.restore();
}

function drawFruit(){
  if(!juiceState.fruit)return;
  const fr=juiceState.fruit;
  const pulse=0.8+Math.sin(globalFrame*0.1)*0.2;
  ctx.save();
  ctx.fillStyle=fr.color;
  ctx.shadowColor=fr.color;ctx.shadowBlur=12*pulse;
  ctx.beginPath();ctx.arc(fr.x+shakeX,fr.y+shakeY,10*pulse,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#fff';ctx.shadowBlur=0;
  ctx.font='bold 10px Orbitron';ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillText(fr.type,fr.x+shakeX,fr.y+shakeY+1);
  ctx.restore();
}

function drawBassVisualizerBars(){
  const isPower=frightenedTimer>0;
  const barCount=10;
  const barW=W/barCount;
  ctx.save();
  for(let i=0;i<barCount;i++){
    const freq=0.03+i*0.007;
    const phase=i*0.8;
    const h=(15+Math.sin(globalFrame*freq+phase)*12+Math.sin(globalFrame*0.05+i)*8)*(isPower?2.5:1);
    const alpha=isPower?0.15:0.06;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=isPower?`hsl(${280+i*8},80%,50%)`:`hsl(${200+i*10},60%,40%)`;
    ctx.fillRect(i*barW,H+HUD_H-h,barW-2,h);
  }
  ctx.restore();
}

function drawDotChainGlow(){
  if(juiceState.dotStreak<3||pacman.deathTimer>0)return;
  const faceDir=pacman.lastDir||pacman.dir;
  if(!faceDir||faceDir===DIR.NONE)return;
  const pg=pxToGrid(pacman.x,pacman.y);
  ctx.save();
  for(let i=1;i<=5;i++){
    const gx=pg.x+faceDir.x*i,gy=pg.y+faceDir.y*i;
    if(gx<0||gx>=COLS||gy<0||gy>=ROWS)break;
    if(maze[gy][gx]===1)break;
    if(maze[gy][gx]!==2)continue;
    const dx=gx*T+T/2,dy=gy*T+T/2+HUD_H;
    const glow=Math.max(0.2,(6-i)/5);
    ctx.globalAlpha=glow*0.6;
    ctx.fillStyle='#fff';
    ctx.shadowColor='#ffdd44';ctx.shadowBlur=15*glow;
    ctx.beginPath();ctx.arc(dx+shakeX,dy+shakeY,3,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawKillStreak(){
  if(juiceState.ghostsEatenThisPower<2||frightenedTimer<=0)return;
  const labels=['','','DOUBLE KILL!','TRIPLE KILL!','QUADRA KILL!!!'];
  const text=labels[Math.min(juiceState.ghostsEatenThisPower,4)];
  const pulse=0.8+Math.sin(globalFrame*0.15)*0.2;
  ctx.save();
  ctx.globalAlpha=Math.min(1,frightenedTimer/60);
  const hue=(globalFrame*12)%360;
  ctx.fillStyle=`hsl(${hue},100%,60%)`;
  ctx.shadowColor=`hsl(${hue},100%,70%)`;ctx.shadowBlur=15;
  ctx.font=`bold ${Math.floor(34*pulse)}px Orbitron`;
  ctx.textAlign='center';
  ctx.fillText(text,W/2,H/2-40+HUD_H/2);
  ctx.restore();
}

function drawNearMiss(){
  if(juiceState.nearMissTimer<=0)return;
  const alpha=juiceState.nearMissTimer/60;
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.fillStyle='#ff4444';ctx.shadowColor='#ff0000';ctx.shadowBlur=20;
  ctx.font='bold 20px Orbitron';ctx.textAlign='center';
  ctx.fillText('CLOSE CALL!',W/2,H/2+50+HUD_H/2);
  ctx.restore();
}

function drawPlayingScreen(){
  drawBackground();
  drawBassPulse();
  drawStarField();
  
  ctx.save();
  ctx.translate(shakeX,shakeY);
  const zoom=juiceState.screenZoom||1;
  if(zoom>1.001){ctx.translate(W/2,H/2+HUD_H/2);ctx.scale(zoom,zoom);ctx.translate(-W/2,-(H/2+HUD_H/2));}
  drawMaze();
  drawPulseWaves();
  drawDots();
  drawDotChainGlow();
  drawDotMagnetize();
  drawDotRipples();
  drawFruit();
  drawGhostTrails();
  ghosts.forEach(drawGhost);
  drawPacTrail();
  drawSpeedLines();
  drawPacman();
  drawParticles();
  drawFloatingTexts();
  drawComboTexts();
  drawLightningBolts();
  drawDeathShockwave();
  drawGhostZoom();
  ctx.restore();
  
  drawBassVisualizerBars();
  drawPowerAtmosphere();
  drawLevelComplete();
  drawKillStreak();
  drawNearMiss();
  drawDeathDesaturate();
  drawFlash();
  drawHUD();
  drawScorePop();
  drawPowerChromaticAberration();
  drawCRT();
}

function draw(){
  switch(gameState){
    case'title':drawTitleScreen();break;
    case'ready':drawReadyScreen();break;
    case'playing':case'levelcomplete':drawPlayingScreen();break;
    case'gameover':drawGameOverScreen();break;
  }
}

// Input
const keys={};
window.addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  
  if(e.code==='Space'){
    if(audioCtx.state==='suspended')audioCtx.resume();
    initMusic();
    if(gameState==='title'){resetLevel();}
    else if(gameState==='gameover'){initGame();resetLevel();}
  }
  
  if(gameState==='playing'){
    if(e.code==='ArrowLeft'||e.code==='KeyA')pacman.nextDir=DIR.LEFT;
    if(e.code==='ArrowRight'||e.code==='KeyD')pacman.nextDir=DIR.RIGHT;
    if(e.code==='ArrowUp'||e.code==='KeyW')pacman.nextDir=DIR.UP;
    if(e.code==='ArrowDown'||e.code==='KeyS')pacman.nextDir=DIR.DOWN;
  }
});
window.addEventListener('keyup',e=>{keys[e.code]=false;});
canvas.addEventListener('click',()=>{
  if(audioCtx.state==='suspended')audioCtx.resume();
  initMusic();
  if(gameState==='title'){resetLevel();}
  else if(gameState==='gameover'){initGame();resetLevel();}
});

// Touch controls
let touchStartX=0,touchStartY=0;
canvas.addEventListener('touchstart',e=>{
  e.preventDefault();
  const t=e.touches[0];
  touchStartX=t.clientX;touchStartY=t.clientY;
  if(audioCtx.state==='suspended')audioCtx.resume();
  initMusic();
  if(gameState==='title'){resetLevel();}
  else if(gameState==='gameover'){initGame();resetLevel();}
},{passive:false});
canvas.addEventListener('touchmove',e=>{
  e.preventDefault();
  if(gameState!=='playing')return;
  const t=e.touches[0];
  const dx=t.clientX-touchStartX,dy=t.clientY-touchStartY;
  if(Math.abs(dx)+Math.abs(dy)<15)return;
  if(Math.abs(dx)>Math.abs(dy)){
    pacman.nextDir=dx>0?DIR.RIGHT:DIR.LEFT;
  }else{
    pacman.nextDir=dy>0?DIR.DOWN:DIR.UP;
  }
  touchStartX=t.clientX;touchStartY=t.clientY;
},{passive:false});

// Game loop
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

initGame();
gameLoop();
</script>
</body>
</html>
